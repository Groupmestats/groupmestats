#!/usr/bin/ruby
require 'rubygems'
require 'json'
require 'yaml'
require 'httparty'
require 'optparse'
require 'time'
require 'sqlite3'

$file
$group_id
$database = {}
$time = Time.now.to_i

#Define option flags
optparse = OptionParser.new do |opts|
    opts.banner = "Groupme ultility that pulls messages at a given interval and write them to a SQLite database\nUsage: scraper [OPTIONS]\n\nDo not run unless you have run configure_scraper first.\n\nOptions:\n\n"

    opts.on('-f config','--config=CONFIG_FILE', 'Groupme API config file.  Default is <PROJECT_TREE>/etc/groupme.yaml') do |config_file|
        $file = config_file
    end
    opts.on('-t time','--time=TIME','How long in the past you wish to retreive messages, in seconds. By default, scraper will pull all messages from a group if a time isn\'t specified.') do |input_time|
        $time = input_time.to_i
    end
    opts.on( '-h', '--help', 'Display this screen' ) do
        puts opts
        exit
    end
end

optparse.parse!

#Class that invokes HTTParty.  This passes in a config file for Groupme API.
#See the attached groupme.yaml.example for details
class Groupme
    include HTTParty

    if $file.nil?
        abort('You need to pass a configuratin file')
    else
        begin
            groupme = YAML.load_file($file)
        rescue
            abort('Configuration file not found.  Exiting...')
        end
    
        $token = groupme['groupme']['token']
        $database = groupme['groupme']['database']
        $group_id = groupme['groupme']['group_id']
        base_uri groupme['groupme']['api']
        format :json

        def get(query)
            new_query = query + "token=#{$token}"
            response = self.class.get(new_query, :verify => false)

            retry_attempts = 0

            if response.code != 200            
                if response.nil?
                    abort('No more messages returned from groupme. Perhaps you have pulled all available messages?')
                end
                while retry_attempts < 3 do
                    puts "Could not connect to groupme.com.  Will retry in 60 seconds"       
                    sleep(60)
                    self.class.get(query)
                    retry_attempts += 1
                end
                if retry_attempts >= 3
                    abort('Could not connect to groupme')
                end
            end
            return response
        end
    end
end

#This will populate the uid and current name of all new users to the users table
#of the database.
def populateUsers
    gm = Groupme.new
    database = SQLite3::Database.new( $database )
    merrifield = gm.get("/groups/#{$group_id}/?")
    merrifield['response']['members'].each do | member |
        if database.execute( "SELECT * FROM users WHERE user_id='#{member['user_id']}'").empty?
            database.execute( "INSERT INTO users(Name, user_id) VALUES (?, ?)", 
            member['nickname'], 
            member['user_id'] )
        end
    end
end

#This will pull all messages for a given period of time, and store it in the messages table
#Argument 1 - time, in epoch seconds, to start the search.  0 is the present
#Argument 2 - how far back to search, in epoch seconds.
def scrapeMessages(id, searchTime)
    gm = Groupme.new
    database = SQLite3::Database.new( $database ) 
    
    merrifield = gm.get("groups/#{$group_id}/?") 

    if id == 0
        messages = gm.get("groups/#{$group_id}/messages?")
    else
        messages = gm.get("groups/#{$group_id}/messages?before_id=#{id}&")
    end

    messages['response']['messages'].each do | message |
        t = Time.at(message['created_at'])
        if ((Time.now.to_i - t.to_i) < searchTime)
           if database.execute( "SELECT * FROM messages WHERE message_id='#{message['id']}'").empty?
               image = "none"
               liked_users = ""
               num_likes = 0
               if !message['attachments'].empty?
                   if message['attachments'][0]['type'] == "image"
                      image = message['attachments'][0]['url'] 
                   end
               end
               if !message['favorited_by'].nil?
                   if message['favorited_by'].length != 0
                       message['favorited_by'].each do | user |
                           database.execute( "INSERT INTO likes(message_id, user_id) VALUES (?, ?)",
                           message['id'], 
                           user )
                       end
                   end 
               end
               if !message['text'].nil?
                   database.execute( "INSERT INTO messages(message_id, created_at, user_id, group_id, avatar_url, text, image) VALUES (?, datetime('#{message['created_at']}', 'unixepoch'), ?, ?, ?, ?, ?)",
                   message['id'],
                   message['user_id'],
                   message['group_id'],
                   message['avatar_url'], 
                   message['text'], 
                   image )
               else
                   database.execute( "INSERT INTO messages(message_id, created_at, user_id, group_id, avatar_url, text, image) VALUES (?, datetime('#{message['created_at']}', 'unixepoch'), ?, ?, ?, ?, ?)",
                   message['id'],
                   message['user_id'],
                   message['group_id'],
                   message['avatar_url'], 
                   'none', 
                   image )
               end
           end
           message['favorited_by'].each do | likedMembers |
               if database.execute("SELECT count(user_id) FROM likes WHERE message_id=#{message['id']} AND user_id=#{likedMembers}")[0][0] == 0
                   database.execute("INSERT INTO likes(message_id, user_id) VALUES (?, ?)",
                   message['id'], 
                   likedMembers ) 
               end 
           end
        end
    end

    t = messages['response']['messages'].last['created_at']
    
    if ((Time.now.to_i - t) < searchTime)
        scrapeMessages(messages['response']['messages'].last['id'], searchTime)
    end
end

populateUsers
scrapeMessages(0, $time)
